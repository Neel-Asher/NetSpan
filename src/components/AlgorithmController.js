import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import React from 'react';
import { Button } from './ui/button';
import { Card, CardContent, CardHeader, CardTitle } from './ui/card';
import { Badge } from './ui/badge';
import { Separator } from './ui/separator';
import { Progress } from './ui/progress';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from './ui/select';
import { Play, Pause, SkipForward, RotateCcw, FastForward, GitCompare } from 'lucide-react';
export function AlgorithmController({ algorithmState, algorithmType, isRunning, onStep, onPlay, onPause, onReset, onSpeedChange, onAlgorithmChange, speed, comparisonMode = false, onToggleComparison }) {
    if (!algorithmState)
        return null;
    const progress = algorithmState.totalSteps > 0
        ? (algorithmState.step / algorithmState.totalSteps) * 100
        : 0;
    const getEdgeStatusBadge = (status) => {
        const variants = {
            pending: 'secondary',
            considering: 'default',
            accepted: 'default',
            rejected: 'destructive'
        };
        return (_jsx(Badge, { variant: variants[status], children: status.charAt(0).toUpperCase() + status.slice(1) }));
    };
    const getAlgorithmTitle = () => {
        if (comparisonMode)
            return 'Algorithm Comparison';
        return algorithmType === 'kruskal' ? "Kruskal's Algorithm" : "Prim's Algorithm";
    };
    const getAlgorithmDescription = () => {
        if (algorithmType === 'kruskal') {
            return "Sorts all edges by weight and adds them if they don't create cycles. Uses Union-Find for cycle detection.";
        }
        else {
            return "Grows the MST from a starting vertex by always adding the minimum weight edge to an unvisited node.";
        }
    };
    return (_jsxs("div", { className: "space-y-4", children: [_jsxs(Card, { children: [_jsx(CardHeader, { children: _jsxs(CardTitle, { className: "flex items-center justify-between", children: [getAlgorithmTitle(), _jsxs(Badge, { variant: "outline", children: ["Step ", algorithmState.step, " / ", algorithmState.totalSteps] })] }) }), _jsxs(CardContent, { className: "space-y-4", children: [_jsxs("div", { className: "flex items-center gap-2", children: [_jsxs(Select, { value: algorithmType, onValueChange: onAlgorithmChange, children: [_jsx(SelectTrigger, { className: "w-full", children: _jsx(SelectValue, {}) }), _jsxs(SelectContent, { children: [_jsx(SelectItem, { value: "kruskal", children: "Kruskal's Algorithm" }), _jsx(SelectItem, { value: "prim", children: "Prim's Algorithm" })] })] }), onToggleComparison && (_jsx(Button, { onClick: onToggleComparison, variant: "outline", size: "sm", className: "flex-shrink-0", children: _jsx(GitCompare, { className: "w-4 h-4" }) }))] }), _jsx("p", { className: "text-xs text-muted-foreground leading-relaxed", children: getAlgorithmDescription() }), _jsx(Progress, { value: progress, className: "w-full" }), _jsxs("div", { className: "flex items-center gap-2", children: [_jsx(Button, { onClick: onReset, variant: "outline", size: "sm", disabled: isRunning, children: _jsx(RotateCcw, { className: "w-4 h-4" }) }), _jsx(Button, { onClick: isRunning ? onPause : onPlay, variant: "default", size: "sm", disabled: algorithmState.completed, children: isRunning ? _jsx(Pause, { className: "w-4 h-4" }) : _jsx(Play, { className: "w-4 h-4" }) }), _jsx(Button, { onClick: onStep, variant: "outline", size: "sm", disabled: isRunning || algorithmState.completed, children: _jsx(SkipForward, { className: "w-4 h-4" }) }), _jsx(Separator, { orientation: "vertical", className: "h-6" }), _jsxs("div", { className: "flex items-center gap-2", children: [_jsx(FastForward, { className: "w-4 h-4" }), _jsxs("select", { value: speed, onChange: (e) => onSpeedChange(Number(e.target.value)), className: "px-2 py-1 text-xs border rounded bg-background border-border text-foreground", children: [_jsx("option", { value: 2000, children: "0.5x" }), _jsx("option", { value: 1000, children: "1x" }), _jsx("option", { value: 500, children: "2x" }), _jsx("option", { value: 250, children: "4x" })] })] })] })] })] }), _jsxs(Card, { children: [_jsx(CardHeader, { children: _jsx(CardTitle, { children: "Statistics" }) }), _jsxs(CardContent, { className: "space-y-3", children: [_jsxs("div", { className: "grid grid-cols-2 gap-4", children: [_jsxs("div", { children: [_jsx("div", { className: "text-sm text-muted-foreground", children: "MST Edges" }), _jsx("div", { className: "text-lg", children: algorithmState.mstEdges.length })] }), _jsxs("div", { children: [_jsx("div", { className: "text-sm text-muted-foreground", children: "Total Cost" }), _jsx("div", { className: "text-lg", children: algorithmState.totalCost })] })] }), _jsx(Separator, {}), _jsxs("div", { children: [_jsx("div", { className: "text-sm text-muted-foreground mb-2", children: "Progress" }), _jsxs("div", { className: "grid grid-cols-2 gap-2 text-xs", children: [_jsxs("div", { className: "flex items-center justify-between", children: [_jsx("span", { children: "Completed:" }), _jsx("span", { children: algorithmState.step })] }), _jsxs("div", { className: "flex items-center justify-between", children: [_jsx("span", { children: "Remaining:" }), _jsx("span", { children: algorithmState.totalSteps - algorithmState.step })] })] })] }), algorithmType === 'prim' && 'visitedNodes' in algorithmState && (_jsxs(_Fragment, { children: [_jsx(Separator, {}), _jsxs("div", { children: [_jsx("div", { className: "text-sm text-muted-foreground mb-2", children: "Prim's Progress" }), _jsxs("div", { className: "text-xs", children: [_jsxs("div", { className: "flex items-center justify-between", children: [_jsx("span", { children: "Visited Nodes:" }), _jsx("span", { children: algorithmState.visitedNodes.size })] }), _jsxs("div", { className: "flex items-center justify-between", children: [_jsx("span", { children: "Candidate Edges:" }), _jsx("span", { children: algorithmState.candidateEdges.length })] })] })] })] }))] })] }), _jsxs(Card, { children: [_jsx(CardHeader, { children: _jsx(CardTitle, { children: "Step-by-Step Explanation" }) }), _jsxs(CardContent, { children: [_jsx("p", { className: "text-sm text-muted-foreground leading-relaxed", children: algorithmState.explanation }), algorithmState.currentEdge && (_jsxs("div", { className: "mt-3 p-3 bg-muted rounded-lg", children: [_jsxs("div", { className: "flex items-center justify-between", children: [_jsx("span", { className: "text-sm", children: "Current Edge:" }), getEdgeStatusBadge(algorithmState.currentEdge.status)] }), _jsxs("div", { className: "text-sm mt-1", children: [algorithmState.currentEdge.source, " \u2194 ", algorithmState.currentEdge.target, "(Weight: ", algorithmState.currentEdge.weight, ")"] })] })), algorithmState.completed && (_jsxs("div", { className: "mt-3 p-3 bg-green-50 dark:bg-green-950/20 border border-green-200 dark:border-green-800 rounded-lg", children: [_jsx("div", { className: "text-sm font-medium text-green-800 dark:text-green-200", children: "\uD83C\uDF89 Algorithm Completed!" }), _jsxs("div", { className: "text-xs text-green-700 dark:text-green-300 mt-1", children: ["Minimum Spanning Tree found with total cost: ", algorithmState.totalCost] })] }))] })] }), comparisonMode && (_jsxs(Card, { children: [_jsx(CardHeader, { children: _jsx(CardTitle, { children: "Algorithm Comparison" }) }), _jsx(CardContent, { className: "space-y-3", children: _jsx("div", { className: "text-xs leading-relaxed", children: _jsxs("div", { className: "grid grid-cols-1 gap-3", children: [_jsxs("div", { children: [_jsx("div", { className: "font-medium text-blue-600 dark:text-blue-400", children: "Kruskal's Algorithm" }), _jsxs("div", { className: "text-muted-foreground", children: ["\u2022 Global approach: considers all edges", _jsx("br", {}), "\u2022 Uses Union-Find for cycle detection", _jsx("br", {}), "\u2022 Time: O(E log E), Space: O(V)"] })] }), _jsxs("div", { children: [_jsx("div", { className: "font-medium text-green-600 dark:text-green-400", children: "Prim's Algorithm" }), _jsxs("div", { className: "text-muted-foreground", children: ["\u2022 Local approach: grows from starting node", _jsx("br", {}), "\u2022 Uses priority queue for edge selection", _jsx("br", {}), "\u2022 Time: O(E log V), Space: O(V)"] })] })] }) }) })] }))] }));
}
